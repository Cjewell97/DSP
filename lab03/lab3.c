/*
 * Example program to illustrate the use of the ECE 486 interface.
 * 
 * An input waveform is copied to the output DAC.  The waveform is also
 * squared and streamed to the second DAC output.  Each
 * USER button press inverts the signal on the original DAC.
 * 
 * The use of printf(), the pushbutton, and the LCD is also illustrated.
 */

#include "stm32l4xx_hal.h"
#include "stm32l476g_discovery.h"

#include "ece486.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "arm_math.h"

extern FlagStatus KeyPressed;   // Use to detect button presses

int main(void)
{
  int nsamp;
  float32_t *input, *output1, *output2;
	float32_t *bState, *fState;
  static int button_count = 0;
  
	float32_t bq_coef[10] = {
		1, 1.618, 1, 1.5371, -0.9025,
		1, -0.618, 1, 0.0, 0.81
	};
	int nstage = 1;

	float g = .0139;

	//float fir_coef[20];
	//for(int i=0; i < 20; i++){
	//	fir_coef[i] = 1/20;
	//}
	float32_t fir_coef[20] = {
		1, .2, 1.2, -.3, .5,
		1, .2, -1, 1.3, -.4,
		.5, -.2, .5, 1.5, 1,
		1, 1, -.7, 1.3, .9
	};
	int n_fir = 20;

	char lcd_str[8];

  /*
   * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
   * 
   * If your discovery board has been modified to support the external 
   * HSE reference, use the (better quality crystal controlled) HSE 
   * configuration.  If not, you can use the MSI reference, and things 
   * should still work -- but your clocks will drift over time.
   * 
   * The MSI (Medium speed internal) reference is the on-chip RC oscillator
   * 
   * The HSE (High speed external) reference is an external clock, either
   * provided through the external connector, or (if your board is modified)
   * from the crystal reference source generated by the other processor
   * on the development board.
   */
  // initialize_ece486(FS_50K, MONO_IN, STEREO_OUT, MSI_INTERNAL_RC);
  initialize_ece486(FS_48K, MONO_IN, STEREO_OUT, HSE_EXTERNAL_8MHz);
	printf("initialized");
  
  /*
   * Allocate Required Memory
   *i
   */
  nsamp = getblocksize();
	
  input = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output1 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output2 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
	bState = (float32_t *)calloc(2 * nstage, sizeof(float32_t));
	fState = (float32_t *)calloc(n_fir + nsamp - 1, sizeof(float32_t));
  
  if (input==NULL || output1==NULL || output2==NULL) {
    flagerror(MEMORY_ALLOCATION_ERROR);
    while(1);
  }
  
  /*
   * Normally we avoid printf()... especially once we start actually 
   * processing streaming samples.  This is here to illustrate the 
   * use of printf for debugging programs.
   * 
   * To see the printf output, connect to the ST-Link serial port.
   * Use: 115200 8N1
   */
  // printf("Starting execution using %d samples per input block.\n",nsamp);
  
  /*
   * Infinite Loop to process the data stream, "nsamp" samples at a time
   */
	arm_fir_instance_f32 F = {n_fir, fState, fir_coef};
	arm_biquad_cascade_df2T_instance_f32 B = {nstage, bState, bq_coef};
	

  while(1){
    /*
     * Ask for a block of ADC samples to be put into the working buffer
     *   getblock() will wait here until the input buffer is filled...  On return
     *   we work on the new data buffer... then return here to wait for 
     *   the next block
     */
    getblock(input);	

    /*
     * signal processing code to calculate the required output buffers
     */
    
    DIGITAL_IO_SET();	// Use a scope on PD0 to measure execution time
    DIGITAL_IO_RESET();	// (falling edge....  done processing data )
    /*
     * pass the processed working buffer back for DAC output
     */
		
		arm_fir_f32(&F,input, output1, nsamp);
		arm_biquad_cascade_df2T_f32(&B, input, output2, nsamp);
  	

		for(int i = 0; i<nsamp; i++){
			output2[i] *= 2;
		}

		putblockstereo(output1,output2);

   // if (KeyPressed) {
   //   KeyPressed = RESET;
   //   
   //   /*
   //    * On each press, modify the LCD display, and toggle an LED
   //    * (LED4=red, LED5=green) (Red is used to show error conditions)
   //    * 
   //    * Don't be surprised when these cause a Sample Overrun error, 
   //    * depending on your sample rate.
   //    */
   //   button_count++;
	 // 	char names[4][6] = {"aidan ", "caleb ", "sam   ", "tyler "};
   //   sprintf(lcd_str, "%s", names[button_count%4]);
   //   BSP_LCD_GLASS_DisplayString( (uint8_t *)lcd_str);
   //   BSP_LED_Toggle(LED5);
   // }
  }
}

