#include "stm32l4xx_hal.h"
#include "stm32l476g_discovery.h"

#include "ece486.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "arm_math.h"

extern FlagStatus KeyPressed;   // Use to detect button presses

int main(void)
{
  int nsamp;
  float32_t *input, *output1, *output2;
	float32_t *bState, *fState;
  static int button_count = 0;
  

	float g = .3572;

	// biquad coefficients, a1 and a2 (last 2 on each line)
	//	are negated for the CMSIS implementation
	float32_t bq_coef[] = {
	0.138012, 0.223308, 0.138012, 0.200533, -0.640000, 
	0.216850, -0.412474, 0.216850, 1.090975, -0.792100, 
	1.213542, -1.963553, 1.213542, 1.085273, -0.810000, 
	0.865143, 1.017037, 0.865143, -0.059052, -0.883600 
	};
	
	// number of first order stages
	int nstage = 4;

	// FIR coefficients, set to work as a running average filter
	float32_t fir_coef[20];
	for(int i=0; i < 20; i++){
		fir_coef[i] = 1./20;
	}
	int n_fir = 20;

	char lcd_str[8];

  /*
   * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
   * 
   * If your discovery board has been modified to support the external 
   * HSE reference, use the (better quality crystal controlled) HSE 
   * configuration.  If not, you can use the MSI reference, and things 
   * should still work -- but your clocks will drift over time.
   * 
   * The MSI (Medium speed internal) reference is the on-chip RC oscillator
   * 
   * The HSE (High speed external) reference is an external clock, either
   * provided through the external connector, or (if your board is modified)
   * from the crystal reference source generated by the other processor
   * on the development board.
   */
  // initialize_ece486(FS_50K, MONO_IN, STEREO_OUT, MSI_INTERNAL_RC);
  initialize_ece486(FS_48K, MONO_IN, MONO_OUT, HSE_EXTERNAL_8MHz);
  
  /*
   * Allocate Required Memory
   *
   */
  nsamp = getblocksize();
	
  input = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output1 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output2 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
	bState = (float32_t *)calloc(nstage, sizeof(float32_t));
	fState = (float32_t *)calloc(n_fir + nsamp - 1, sizeof(float32_t));
  
  if (input==NULL || output1==NULL || output2==NULL) {
    flagerror(MEMORY_ALLOCATION_ERROR);
    while(1);
  }
  
	// Initialize fir and biquad filter structs.
	// use the number of 2nd order stages for the biquad filter
	arm_fir_instance_f32 F = {n_fir, fState, fir_coef};
	arm_biquad_cascade_df2T_instance_f32 B = {nstage/2, bState, bq_coef};
	

  /*
   * Infinite Loop to process the data stream, "nsamp" samples at a time
   */
  while(1){
    getblock(input);	

    DIGITAL_IO_SET();	// Use a scope on PD0 to measure execution time
    DIGITAL_IO_RESET();	// (falling edge....  done processing data )
	

		// Calculate the output blocks using the FIR and biquad structs	
		arm_fir_f32(&F,input, output1, nsamp);
		arm_biquad_cascade_df2T_f32(&B, input, output2, nsamp);
  	
		// output block on board. Stereo output has some error with it so use MONO_OUT
		putblock(output2);
  }
}

